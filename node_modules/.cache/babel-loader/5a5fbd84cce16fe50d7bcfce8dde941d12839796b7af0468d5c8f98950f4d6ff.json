{"ast":null,"code":"import { defaultJsonSerializer } from './defaultJsonSerializer.js';\nimport { HeadersInstanceToPlainObject, uppercase } from './helpers.js';\nimport { parseBatchRequestArgs, parseRawRequestArgs, parseRawRequestExtendedArgs, parseRequestArgs, parseRequestExtendedArgs } from './parseArgs.js';\nimport { resolveRequestDocument } from './resolveRequestDocument.js';\nimport { ClientError } from './types.js';\nimport crossFetch, * as CrossFetch from 'cross-fetch';\n/**\n * Convert the given headers configuration into a plain object.\n */\nconst resolveHeaders = headers => {\n  let oHeaders = {};\n  if (headers) {\n    if (typeof Headers !== `undefined` && headers instanceof Headers || CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers) {\n      oHeaders = HeadersInstanceToPlainObject(headers);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(_ref => {\n        let [name, value] = _ref;\n        if (name && value !== undefined) {\n          oHeaders[name] = value;\n        }\n      });\n    } else {\n      oHeaders = headers;\n    }\n  }\n  return oHeaders;\n};\n/**\n * Clean a GraphQL document to send it via a GET query\n */\nconst cleanQuery = str => str.replace(/([\\s,]|#[^\\n\\r]+)+/g, ` `).trim();\n/**\n * Create query string for GraphQL request\n */\nconst buildRequestConfig = params => {\n  if (!Array.isArray(params.query)) {\n    const params_ = params;\n    const search = [`query=${encodeURIComponent(cleanQuery(params_.query))}`];\n    if (params.variables) {\n      search.push(`variables=${encodeURIComponent(params_.jsonSerializer.stringify(params_.variables))}`);\n    }\n    if (params_.operationName) {\n      search.push(`operationName=${encodeURIComponent(params_.operationName)}`);\n    }\n    return search.join(`&`);\n  }\n  if (typeof params.variables !== `undefined` && !Array.isArray(params.variables)) {\n    throw new Error(`Cannot create query with given variable type, array expected`);\n  }\n  // Batch support\n  const params_ = params;\n  const payload = params.query.reduce((acc, currentQuery, index) => {\n    acc.push({\n      query: cleanQuery(currentQuery),\n      variables: params_.variables ? params_.jsonSerializer.stringify(params_.variables[index]) : undefined\n    });\n    return acc;\n  }, []);\n  return `query=${encodeURIComponent(params_.jsonSerializer.stringify(payload))}`;\n};\nconst createHttpMethodFetcher = method => async params => {\n  const {\n    url,\n    query,\n    variables,\n    operationName,\n    fetch,\n    fetchOptions,\n    middleware\n  } = params;\n  const headers = {\n    ...params.headers\n  };\n  let queryParams = ``;\n  let body = undefined;\n  if (method === `POST`) {\n    body = createRequestBody(query, variables, operationName, fetchOptions.jsonSerializer);\n    if (typeof body === `string`) {\n      // @ts-expect-error todo\n      headers[`Content-Type`] = `application/json`;\n    }\n  } else {\n    // @ts-expect-error todo needs ADT for TS to understand the different states\n    queryParams = buildRequestConfig({\n      query,\n      variables,\n      operationName,\n      jsonSerializer: fetchOptions.jsonSerializer ?? defaultJsonSerializer\n    });\n  }\n  const init = {\n    method,\n    headers,\n    body,\n    ...fetchOptions\n  };\n  let urlResolved = url;\n  let initResolved = init;\n  if (middleware) {\n    const result = await Promise.resolve(middleware({\n      ...init,\n      url,\n      operationName,\n      variables\n    }));\n    const {\n      url: urlNew,\n      ...initNew\n    } = result;\n    urlResolved = urlNew;\n    initResolved = initNew;\n  }\n  if (queryParams) {\n    urlResolved = `${urlResolved}?${queryParams}`;\n  }\n  return await fetch(urlResolved, initResolved);\n};\n/**\n * GraphQL Client.\n */\nclass GraphQLClient {\n  constructor(url) {\n    var _this = this;\n    let requestConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.url = url;\n    this.requestConfig = requestConfig;\n    /**\n     * Send a GraphQL query to the server.\n     */\n    this.rawRequest = async function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const [queryOrOptions, variables, requestHeaders] = args;\n      const rawRequestOptions = parseRawRequestArgs(queryOrOptions, variables, requestHeaders);\n      const {\n        headers,\n        fetch = crossFetch,\n        method = `POST`,\n        requestMiddleware,\n        responseMiddleware,\n        ...fetchOptions\n      } = _this.requestConfig;\n      const {\n        url\n      } = _this;\n      if (rawRequestOptions.signal !== undefined) {\n        fetchOptions.signal = rawRequestOptions.signal;\n      }\n      const {\n        operationName\n      } = resolveRequestDocument(rawRequestOptions.query);\n      return makeRequest({\n        url,\n        query: rawRequestOptions.query,\n        variables: rawRequestOptions.variables,\n        headers: {\n          ...resolveHeaders(callOrIdentity(headers)),\n          ...resolveHeaders(rawRequestOptions.requestHeaders)\n        },\n        operationName,\n        fetch,\n        method,\n        fetchOptions,\n        middleware: requestMiddleware\n      }).then(response => {\n        if (responseMiddleware) {\n          responseMiddleware(response);\n        }\n        return response;\n      }).catch(error => {\n        if (responseMiddleware) {\n          responseMiddleware(error);\n        }\n        throw error;\n      });\n    };\n  }\n  async request(documentOrOptions) {\n    for (var _len2 = arguments.length, variablesAndRequestHeaders = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      variablesAndRequestHeaders[_key2 - 1] = arguments[_key2];\n    }\n    const [variables, requestHeaders] = variablesAndRequestHeaders;\n    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders);\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig;\n    const {\n      url\n    } = this;\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal;\n    }\n    const {\n      query,\n      operationName\n    } = resolveRequestDocument(requestOptions.document);\n    return makeRequest({\n      url,\n      query,\n      variables: requestOptions.variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(requestOptions.requestHeaders)\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware\n    }).then(response => {\n      if (responseMiddleware) {\n        responseMiddleware(response);\n      }\n      return response.data;\n    }).catch(error => {\n      if (responseMiddleware) {\n        responseMiddleware(error);\n      }\n      throw error;\n    });\n  }\n  // prettier-ignore\n  batchRequests(documentsOrOptions, requestHeaders) {\n    const batchRequestOptions = parseBatchRequestArgs(documentsOrOptions, requestHeaders);\n    const {\n      headers,\n      ...fetchOptions\n    } = this.requestConfig;\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal;\n    }\n    const queries = batchRequestOptions.documents.map(_ref2 => {\n      let {\n        document\n      } = _ref2;\n      return resolveRequestDocument(document).query;\n    });\n    const variables = batchRequestOptions.documents.map(_ref3 => {\n      let {\n        variables\n      } = _ref3;\n      return variables;\n    });\n    return makeRequest({\n      url: this.url,\n      query: queries,\n      // @ts-expect-error TODO reconcile batch variables into system.\n      variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(batchRequestOptions.requestHeaders)\n      },\n      operationName: undefined,\n      fetch: this.requestConfig.fetch ?? crossFetch,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware\n    }).then(response => {\n      if (this.requestConfig.responseMiddleware) {\n        this.requestConfig.responseMiddleware(response);\n      }\n      return response.data;\n    }).catch(error => {\n      if (this.requestConfig.responseMiddleware) {\n        this.requestConfig.responseMiddleware(error);\n      }\n      throw error;\n    });\n  }\n  setHeaders(headers) {\n    this.requestConfig.headers = headers;\n    return this;\n  }\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key, value) {\n    const {\n      headers\n    } = this.requestConfig;\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      //@ts-expect-error todo\n      headers[key] = value;\n    } else {\n      this.requestConfig.headers = {\n        [key]: value\n      };\n    }\n    return this;\n  }\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value) {\n    this.url = value;\n    return this;\n  }\n}\nconst makeRequest = async params => {\n  const {\n    query,\n    variables,\n    fetchOptions\n  } = params;\n  const fetcher = createHttpMethodFetcher(uppercase(params.method ?? `post`));\n  const isBatchingQuery = Array.isArray(params.query);\n  const response = await fetcher(params);\n  const result = await getResult(response, fetchOptions.jsonSerializer ?? defaultJsonSerializer);\n  const successfullyReceivedData = Array.isArray(result) ? !result.some(_ref4 => {\n    let {\n      data\n    } = _ref4;\n    return !data;\n  }) : Boolean(result.data);\n  const successfullyPassedErrorPolicy = Array.isArray(result) || !result.errors || Array.isArray(result.errors) && !result.errors.length || fetchOptions.errorPolicy === `all` || fetchOptions.errorPolicy === `ignore`;\n  if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {\n    // @ts-expect-error TODO fixme\n    const {\n      errors: _,\n      ...rest\n    } = Array.isArray(result) ? result : result;\n    const data = fetchOptions.errorPolicy === `ignore` ? rest : result;\n    const dataEnvelope = isBatchingQuery ? {\n      data\n    } : data;\n    // @ts-expect-error TODO\n    return {\n      ...dataEnvelope,\n      headers: response.headers,\n      status: response.status\n    };\n  } else {\n    const errorResult = typeof result === `string` ? {\n      error: result\n    } : result;\n    throw new ClientError(\n    // @ts-expect-error TODO\n    {\n      ...errorResult,\n      status: response.status,\n      headers: response.headers\n    }, {\n      query,\n      variables\n    });\n  }\n};\n/**\n * Send a GraphQL Query to the GraphQL server for execution.\n */\nconst rawRequest = async function () {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n  const [urlOrOptions, query, ...variablesAndRequestHeaders] = args;\n  const requestOptions = parseRawRequestExtendedArgs(urlOrOptions, query, ...variablesAndRequestHeaders);\n  const client = new GraphQLClient(requestOptions.url);\n  return client.rawRequest({\n    ...requestOptions\n  });\n};\n// prettier-ignore\n// eslint-disable-next-line\nasync function request(urlOrOptions, document) {\n  for (var _len4 = arguments.length, variablesAndRequestHeaders = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n    variablesAndRequestHeaders[_key4 - 2] = arguments[_key4];\n  }\n  const requestOptions = parseRequestExtendedArgs(urlOrOptions, document, ...variablesAndRequestHeaders);\n  const client = new GraphQLClient(requestOptions.url);\n  return client.request({\n    ...requestOptions\n  });\n}\n/**\n * Send a batch of GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await batchRequests('https://foo.bar/graphql', [\n * {\n *  query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * },\n * {\n *   query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * }])\n *\n * // You can also pass a GraphQL DocumentNode as query. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await batchRequests('https://foo.bar/graphql', [{ query: gql`...` }])\n * ```\n */\nconst batchRequests = async function () {\n  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    args[_key5] = arguments[_key5];\n  }\n  const params = parseBatchRequestsArgsExtended(args);\n  const client = new GraphQLClient(params.url);\n  return client.batchRequests(params);\n};\nconst parseBatchRequestsArgsExtended = args => {\n  if (args.length === 1) {\n    return args[0];\n  } else {\n    return {\n      url: args[0],\n      documents: args[1],\n      requestHeaders: args[2],\n      signal: undefined\n    };\n  }\n};\nconst createRequestBody = (query, variables, operationName, jsonSerializer) => {\n  const jsonSerializer_ = jsonSerializer ?? defaultJsonSerializer;\n  if (!Array.isArray(query)) {\n    return jsonSerializer_.stringify({\n      query,\n      variables,\n      operationName\n    });\n  }\n  if (typeof variables !== `undefined` && !Array.isArray(variables)) {\n    throw new Error(`Cannot create request body with given variable type, array expected`);\n  }\n  // Batch support\n  const payload = query.reduce((acc, currentQuery, index) => {\n    acc.push({\n      query: currentQuery,\n      variables: variables ? variables[index] : undefined\n    });\n    return acc;\n  }, []);\n  return jsonSerializer_.stringify(payload);\n};\nconst getResult = async (response, jsonSerializer) => {\n  let contentType;\n  response.headers.forEach((value, key) => {\n    if (key.toLowerCase() === `content-type`) {\n      contentType = value;\n    }\n  });\n  if (contentType && (contentType.toLowerCase().startsWith(`application/json`) || contentType.toLowerCase().startsWith(`application/graphql+json`) || contentType.toLowerCase().startsWith(`application/graphql-response+json`))) {\n    return jsonSerializer.parse(await response.text());\n  } else {\n    return response.text();\n  }\n};\nconst callOrIdentity = value => {\n  return typeof value === `function` ? value() : value;\n};\n/**\n * Convenience passthrough template tag to get the benefits of tooling for the gql template tag. This does not actually parse the input into a GraphQL DocumentNode like graphql-tag package does. It just returns the string with any variables given interpolated. Can save you a bit of performance and having to install another package.\n *\n * @example\n * ```\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n * ```\n *\n * @remarks\n *\n * Several tools in the Node GraphQL ecosystem are hardcoded to specially treat any template tag named \"gql\". For example see this prettier issue: https://github.com/prettier/prettier/issues/4360. Using this template tag has no runtime effect beyond variable interpolation.\n */\nexport const gql = function (chunks) {\n  for (var _len6 = arguments.length, variables = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    variables[_key6 - 1] = arguments[_key6];\n  }\n  return chunks.reduce((acc, chunk, index) => `${acc}${chunk}${index in variables ? String(variables[index]) : ``}`, ``);\n};\nexport { GraphQLWebSocketClient } from './graphql-ws.js';\nexport { resolveRequestDocument } from './resolveRequestDocument.js';\nexport { batchRequests, ClientError, GraphQLClient, rawRequest, request };\nexport default request;","map":{"version":3,"names":["defaultJsonSerializer","HeadersInstanceToPlainObject","uppercase","parseBatchRequestArgs","parseRawRequestArgs","parseRawRequestExtendedArgs","parseRequestArgs","parseRequestExtendedArgs","resolveRequestDocument","ClientError","crossFetch","CrossFetch","resolveHeaders","headers","oHeaders","Headers","Array","isArray","forEach","_ref","name","value","undefined","cleanQuery","str","replace","trim","buildRequestConfig","params","query","params_","search","encodeURIComponent","variables","push","jsonSerializer","stringify","operationName","join","Error","payload","reduce","acc","currentQuery","index","createHttpMethodFetcher","method","url","fetch","fetchOptions","middleware","queryParams","body","createRequestBody","init","urlResolved","initResolved","result","Promise","resolve","urlNew","initNew","GraphQLClient","constructor","_this","requestConfig","arguments","length","rawRequest","_len","args","_key","queryOrOptions","requestHeaders","rawRequestOptions","requestMiddleware","responseMiddleware","signal","makeRequest","callOrIdentity","then","response","catch","error","request","documentOrOptions","_len2","variablesAndRequestHeaders","_key2","requestOptions","document","data","batchRequests","documentsOrOptions","batchRequestOptions","queries","documents","map","_ref2","_ref3","setHeaders","setHeader","key","setEndpoint","fetcher","isBatchingQuery","getResult","successfullyReceivedData","some","_ref4","Boolean","successfullyPassedErrorPolicy","errors","errorPolicy","ok","_","rest","dataEnvelope","status","errorResult","_len3","_key3","urlOrOptions","client","_len4","_key4","_len5","_key5","parseBatchRequestsArgsExtended","jsonSerializer_","contentType","toLowerCase","startsWith","parse","text","gql","chunks","_len6","_key6","chunk","String","GraphQLWebSocketClient"],"sources":["/Users/dootss/appdevelopment/blast/node_modules/graphql-request/src/index.ts"],"sourcesContent":["import { defaultJsonSerializer } from './defaultJsonSerializer.js'\nimport { HeadersInstanceToPlainObject, uppercase } from './helpers.js'\nimport {\n  parseBatchRequestArgs,\n  parseRawRequestArgs,\n  parseRawRequestExtendedArgs,\n  parseRequestArgs,\n  parseRequestExtendedArgs,\n} from './parseArgs.js'\nimport { resolveRequestDocument } from './resolveRequestDocument.js'\nimport type {\n  BatchRequestDocument,\n  FetchOptions,\n  GraphQLClientRequestHeaders,\n  GraphQLClientResponse,\n  HTTPMethodInput,\n  JsonSerializer,\n  MaybeLazy,\n  RequestConfig,\n  RequestMiddleware,\n  ResponseMiddleware,\n  VariablesAndRequestHeadersArgs,\n} from './types.js'\nimport {\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestOptions,\n  Variables,\n} from './types.js'\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core'\nimport crossFetch, * as CrossFetch from 'cross-fetch'\n\n/**\n * Convert the given headers configuration into a plain object.\n */\nconst resolveHeaders = (headers?: GraphQLClientRequestHeaders): Record<string, string> => {\n  let oHeaders: Record<string, string> = {}\n  if (headers) {\n    if (\n      (typeof Headers !== `undefined` && headers instanceof Headers) ||\n      (CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers)\n    ) {\n      oHeaders = HeadersInstanceToPlainObject(headers)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(([name, value]) => {\n        if (name && value !== undefined) {\n          oHeaders[name] = value\n        }\n      })\n    } else {\n      oHeaders = headers as Record<string, string>\n    }\n  }\n\n  return oHeaders\n}\n\n/**\n * Clean a GraphQL document to send it via a GET query\n */\nconst cleanQuery = (str: string): string => str.replace(/([\\s,]|#[^\\n\\r]+)+/g, ` `).trim()\n\ntype BuildRequestConfigParamsBatch<V> = {\n  query: string[]\n  variables: V[] | undefined\n  operationName: undefined\n  jsonSerializer: JsonSerializer\n}\n\ntype BuildRequestConfigParamsSingle<V> = {\n  query: string\n  variables: V | undefined\n  operationName: string | undefined\n  jsonSerializer: JsonSerializer\n}\n\ntype BuildRequestConfigParams<V> = BuildRequestConfigParamsSingle<V> | BuildRequestConfigParamsBatch<V>\n\n/**\n * Create query string for GraphQL request\n */\nconst buildRequestConfig = <V extends Variables>(params: BuildRequestConfigParams<V>): string => {\n  if (!Array.isArray(params.query)) {\n    const params_ = params as BuildRequestConfigParamsSingle<V>\n    const search: string[] = [`query=${encodeURIComponent(cleanQuery(params_.query))}`]\n\n    if (params.variables) {\n      search.push(`variables=${encodeURIComponent(params_.jsonSerializer.stringify(params_.variables))}`)\n    }\n\n    if (params_.operationName) {\n      search.push(`operationName=${encodeURIComponent(params_.operationName)}`)\n    }\n\n    return search.join(`&`)\n  }\n\n  if (typeof params.variables !== `undefined` && !Array.isArray(params.variables)) {\n    throw new Error(`Cannot create query with given variable type, array expected`)\n  }\n\n  // Batch support\n  const params_ = params as BuildRequestConfigParamsBatch<V>\n  const payload = params.query.reduce<{ query: string; variables: string | undefined }[]>(\n    (acc, currentQuery, index) => {\n      acc.push({\n        query: cleanQuery(currentQuery),\n        variables: params_.variables ? params_.jsonSerializer.stringify(params_.variables[index]) : undefined,\n      })\n      return acc\n    },\n    []\n  )\n\n  return `query=${encodeURIComponent(params_.jsonSerializer.stringify(payload))}`\n}\n\ntype Fetch = (url: string, config: RequestInit) => Promise<Response>\n\ninterface RequestVerbParams<V extends Variables = Variables> {\n  url: string\n  query: string | string[]\n  fetch: Fetch\n  fetchOptions: FetchOptions\n  variables?: V\n  headers?: GraphQLClientRequestHeaders\n  operationName?: string\n  middleware?: RequestMiddleware<V>\n}\n\nconst createHttpMethodFetcher =\n  (method: 'GET' | 'POST') =>\n  async <V extends Variables>(params: RequestVerbParams<V>) => {\n    const { url, query, variables, operationName, fetch, fetchOptions, middleware } = params\n\n    const headers = { ...params.headers }\n    let queryParams = ``\n    let body = undefined\n\n    if (method === `POST`) {\n      body = createRequestBody(query, variables, operationName, fetchOptions.jsonSerializer)\n      if (typeof body === `string`) {\n        // @ts-expect-error todo\n        headers[`Content-Type`] = `application/json`\n      }\n    } else {\n      // @ts-expect-error todo needs ADT for TS to understand the different states\n      queryParams = buildRequestConfig<V>({\n        query,\n        variables,\n        operationName,\n        jsonSerializer: fetchOptions.jsonSerializer ?? defaultJsonSerializer,\n      })\n    }\n\n    const init: RequestInit = {\n      method,\n      headers,\n      body,\n      ...fetchOptions,\n    }\n\n    let urlResolved = url\n    let initResolved = init\n    if (middleware) {\n      const result = await Promise.resolve(middleware({ ...init, url, operationName, variables }))\n      const { url: urlNew, ...initNew } = result\n      urlResolved = urlNew\n      initResolved = initNew\n    }\n    if (queryParams) {\n      urlResolved = `${urlResolved}?${queryParams}`\n    }\n    return await fetch(urlResolved, initResolved)\n  }\n\n/**\n * GraphQL Client.\n */\nclass GraphQLClient {\n  constructor(private url: string, public readonly requestConfig: RequestConfig = {}) {}\n\n  /**\n   * Send a GraphQL query to the server.\n   */\n  rawRequest: RawRequestMethod = async <T, V extends Variables = Variables>(\n    ...args: RawRequestMethodArgs<V>\n  ): Promise<GraphQLClientResponse<T>> => {\n    const [queryOrOptions, variables, requestHeaders] = args\n    const rawRequestOptions = parseRawRequestArgs<V>(queryOrOptions, variables, requestHeaders)\n\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (rawRequestOptions.signal !== undefined) {\n      fetchOptions.signal = rawRequestOptions.signal\n    }\n\n    const { operationName } = resolveRequestDocument(rawRequestOptions.query)\n\n    return makeRequest<T, V>({\n      url,\n      query: rawRequestOptions.query,\n      variables: rawRequestOptions.variables as V,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(rawRequestOptions.requestHeaders),\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n      .then((response) => {\n        if (responseMiddleware) {\n          responseMiddleware(response)\n        }\n        return response\n      })\n      .catch((error) => {\n        if (responseMiddleware) {\n          responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  /**\n   * Send a GraphQL document to the server.\n   */\n  async request<T, V extends Variables = Variables>(\n    document: RequestDocument | TypedDocumentNode<T, V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T>\n  async request<T, V extends Variables = Variables>(options: RequestOptions<V, T>): Promise<T>\n  async request<T, V extends Variables = Variables>(\n    documentOrOptions: RequestDocument | TypedDocumentNode<T, V> | RequestOptions<V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T> {\n    const [variables, requestHeaders] = variablesAndRequestHeaders\n    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders)\n\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal\n    }\n\n    const { query, operationName } = resolveRequestDocument(requestOptions.document)\n\n    return makeRequest<T>({\n      url,\n      query,\n      variables: requestOptions.variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(requestOptions.requestHeaders),\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n      .then((response) => {\n        if (responseMiddleware) {\n          responseMiddleware(response)\n        }\n        return response.data\n      })\n      .catch((error) => {\n        if (responseMiddleware) {\n          responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  /**\n   * Send GraphQL documents in batch to the server.\n   */\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(documents: BatchRequestDocument<V>[], requestHeaders?: GraphQLClientRequestHeaders): Promise<T>\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsOptions<V>): Promise<T>\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(documentsOrOptions: BatchRequestDocument<V>[] | BatchRequestsOptions<V>, requestHeaders?: GraphQLClientRequestHeaders): Promise<T> {\n    const batchRequestOptions = parseBatchRequestArgs<V>(documentsOrOptions, requestHeaders)\n    const { headers, ...fetchOptions } = this.requestConfig\n\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal\n    }\n\n    const queries = batchRequestOptions.documents.map(\n      ({ document }) => resolveRequestDocument(document).query\n    )\n    const variables = batchRequestOptions.documents.map(({ variables }) => variables)\n\n    return makeRequest<T>({\n      url: this.url,\n      query: queries,\n      // @ts-expect-error TODO reconcile batch variables into system.\n      variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(batchRequestOptions.requestHeaders),\n      },\n      operationName: undefined,\n      fetch: this.requestConfig.fetch ?? crossFetch,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware,\n    })\n      .then((response) => {\n        if (this.requestConfig.responseMiddleware) {\n          this.requestConfig.responseMiddleware(response)\n        }\n        return response.data\n      })\n      .catch((error) => {\n        if (this.requestConfig.responseMiddleware) {\n          this.requestConfig.responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  setHeaders(headers: GraphQLClientRequestHeaders): GraphQLClient {\n    this.requestConfig.headers = headers\n    return this\n  }\n\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key: string, value: string): GraphQLClient {\n    const { headers } = this.requestConfig\n\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      //@ts-expect-error todo\n      headers[key] = value\n    } else {\n      this.requestConfig.headers = { [key]: value }\n    }\n\n    return this\n  }\n\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value: string): GraphQLClient {\n    this.url = value\n    return this\n  }\n}\n\nconst makeRequest = async <T = unknown, V extends Variables = Variables>(params: {\n  url: string\n  query: string | string[]\n  variables?: V\n  headers?: GraphQLClientRequestHeaders\n  operationName?: string\n  fetch: Fetch\n  method?: HTTPMethodInput\n  fetchOptions: FetchOptions\n  middleware?: RequestMiddleware<V>\n}): Promise<GraphQLClientResponse<T>> => {\n  const { query, variables, fetchOptions } = params\n  const fetcher = createHttpMethodFetcher(uppercase(params.method ?? `post`))\n  const isBatchingQuery = Array.isArray(params.query)\n  const response = await fetcher(params)\n  const result = await getResult(response, fetchOptions.jsonSerializer ?? defaultJsonSerializer)\n\n  const successfullyReceivedData = Array.isArray(result)\n    ? !result.some(({ data }) => !data)\n    : Boolean(result.data)\n\n  const successfullyPassedErrorPolicy =\n    Array.isArray(result) ||\n    !result.errors ||\n    (Array.isArray(result.errors) && !result.errors.length) ||\n    fetchOptions.errorPolicy === `all` ||\n    fetchOptions.errorPolicy === `ignore`\n\n  if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {\n    // @ts-expect-error TODO fixme\n    const { errors: _, ...rest } = Array.isArray(result) ? result : result\n    const data = fetchOptions.errorPolicy === `ignore` ? rest : result\n    const dataEnvelope = isBatchingQuery ? { data } : data\n\n    // @ts-expect-error TODO\n    return {\n      ...dataEnvelope,\n      headers: response.headers,\n      status: response.status,\n    }\n  } else {\n    const errorResult =\n      typeof result === `string`\n        ? {\n            error: result,\n          }\n        : result\n    throw new ClientError(\n      // @ts-expect-error TODO\n      { ...errorResult, status: response.status, headers: response.headers },\n      { query, variables }\n    )\n  }\n}\n\n// prettier-ignore\ninterface RawRequestMethod {\n  <T, V extends Variables = Variables>(query: string, variables?: V, requestHeaders?: GraphQLClientRequestHeaders): Promise<GraphQLClientResponse<T>>\n  <T, V extends Variables = Variables>(options: RawRequestOptions<V>): Promise<GraphQLClientResponse<T>>\n}\n\n// prettier-ignore\ntype RawRequestMethodArgs<V extends Variables> =\n  | [query: string, variables?: V, requestHeaders?: GraphQLClientRequestHeaders]\n  | [RawRequestOptions<V>]\n\n// prettier-ignore\ninterface RawRequest {\n  <T, V extends Variables = Variables>(url: string, query: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<GraphQLClientResponse<T>>\n  <T, V extends Variables = Variables>(options: RawRequestExtendedOptions<V>): Promise<GraphQLClientResponse<T>>\n}\n\n// prettier-ignore\ntype RawRequestArgs<V extends Variables> = \n  | [options: RawRequestExtendedOptions<V>, query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n  | [url: string,                           query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n\n/**\n * Send a GraphQL Query to the GraphQL server for execution.\n */\nconst rawRequest: RawRequest = async <T, V extends Variables>(\n  ...args: RawRequestArgs<V>\n): Promise<GraphQLClientResponse<T>> => {\n  const [urlOrOptions, query, ...variablesAndRequestHeaders] = args\n  const requestOptions = parseRawRequestExtendedArgs<V>(urlOrOptions, query, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.rawRequest<T, V>({\n    ...requestOptions,\n  })\n}\n\n/**\n * Send a GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await request('https://foo.bar/graphql', `\n *   {\n *     query {\n *       users\n *     }\n *   }\n * `)\n *\n * // You can also pass a GraphQL DocumentNode. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * // If you don't actually care about using DocumentNode but just\n * // want the tooling support for gql template tag like IDE syntax\n * // coloring and prettier autoformat then note you can use the\n * // passthrough gql tag shipped with graphql-request to save a bit\n * // of performance and not have to install another dep into your project.\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n * ```\n */\n// REMARKS: In order to have autocomplete for options work make it the first overload. If not\n// then autocomplete will instead show the various methods for a string, which is not what we want.\n// prettier-ignore\nasync function request<T, V extends Variables = Variables>(options: RequestExtendedOptions<V, T>): Promise<T>\n// prettier-ignore\nasync function request<T, V extends Variables = Variables>(url: string, document: RequestDocument | TypedDocumentNode<T, V>, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<T>\n// prettier-ignore\n// eslint-disable-next-line\nasync function request<T, V extends Variables = Variables>(urlOrOptions: string | RequestExtendedOptions<V, T>, document?: RequestDocument | TypedDocumentNode<T, V>, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<T> {\n  const requestOptions = parseRequestExtendedArgs<V>(urlOrOptions, document, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.request<T, V>({\n    ...requestOptions,\n  })\n}\n\n/**\n * Send a batch of GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await batchRequests('https://foo.bar/graphql', [\n * {\n *  query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * },\n * {\n *   query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * }])\n *\n * // You can also pass a GraphQL DocumentNode as query. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await batchRequests('https://foo.bar/graphql', [{ query: gql`...` }])\n * ```\n */\nconst batchRequests: BatchRequests = async (...args: BatchRequestsArgs) => {\n  const params = parseBatchRequestsArgsExtended(args)\n  const client = new GraphQLClient(params.url)\n  return client.batchRequests(params)\n}\n\ninterface Result<Data extends object = object> {\n  data: Data\n}\n\ntype BatchResult = [Result, ...Result[]]\n\n// prettier-ignore\ninterface BatchRequests {\n  <T extends BatchResult, V extends Variables = Variables>(url: string, documents: BatchRequestDocument<V>[], requestHeaders?: GraphQLClientRequestHeaders): Promise<T>\n  <T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsExtendedOptions<V>): Promise<T>\n}\n\ntype BatchRequestsArgs =\n  | [url: string, documents: BatchRequestDocument[], requestHeaders?: GraphQLClientRequestHeaders]\n  | [options: BatchRequestsExtendedOptions]\n\nconst parseBatchRequestsArgsExtended = (args: BatchRequestsArgs): BatchRequestsExtendedOptions => {\n  if (args.length === 1) {\n    return args[0]\n  } else {\n    return {\n      url: args[0],\n      documents: args[1],\n      requestHeaders: args[2],\n      signal: undefined,\n    }\n  }\n}\n\nconst createRequestBody = (\n  query: string | string[],\n  variables?: Variables | Variables[],\n  operationName?: string,\n  jsonSerializer?: JsonSerializer\n): string => {\n  const jsonSerializer_ = jsonSerializer ?? defaultJsonSerializer\n  if (!Array.isArray(query)) {\n    return jsonSerializer_.stringify({ query, variables, operationName })\n  }\n\n  if (typeof variables !== `undefined` && !Array.isArray(variables)) {\n    throw new Error(`Cannot create request body with given variable type, array expected`)\n  }\n\n  // Batch support\n  const payload = query.reduce<{ query: string; variables: Variables | undefined }[]>(\n    (acc, currentQuery, index) => {\n      acc.push({ query: currentQuery, variables: variables ? variables[index] : undefined })\n      return acc\n    },\n    []\n  )\n\n  return jsonSerializer_.stringify(payload)\n}\n\nconst getResult = async (\n  response: Response,\n  jsonSerializer: JsonSerializer\n): Promise<\n  | { data: object; errors: undefined }[]\n  | { data: object; errors: undefined }\n  | { data: undefined; errors: object }\n  | { data: undefined; errors: object[] }\n> => {\n  let contentType: string | undefined\n\n  response.headers.forEach((value, key) => {\n    if (key.toLowerCase() === `content-type`) {\n      contentType = value\n    }\n  })\n\n  if (\n    contentType &&\n    (contentType.toLowerCase().startsWith(`application/json`) ||\n      contentType.toLowerCase().startsWith(`application/graphql+json`) ||\n      contentType.toLowerCase().startsWith(`application/graphql-response+json`))\n  ) {\n    return jsonSerializer.parse(await response.text()) as any\n  } else {\n    return response.text() as any\n  }\n}\n\nconst callOrIdentity = <T>(value: MaybeLazy<T>) => {\n  return typeof value === `function` ? (value as () => T)() : value\n}\n\n/**\n * Convenience passthrough template tag to get the benefits of tooling for the gql template tag. This does not actually parse the input into a GraphQL DocumentNode like graphql-tag package does. It just returns the string with any variables given interpolated. Can save you a bit of performance and having to install another package.\n *\n * @example\n * ```\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n * ```\n *\n * @remarks\n *\n * Several tools in the Node GraphQL ecosystem are hardcoded to specially treat any template tag named \"gql\". For example see this prettier issue: https://github.com/prettier/prettier/issues/4360. Using this template tag has no runtime effect beyond variable interpolation.\n */\nexport const gql = (chunks: TemplateStringsArray, ...variables: unknown[]): string => {\n  return chunks.reduce(\n    (acc, chunk, index) => `${acc}${chunk}${index in variables ? String(variables[index]) : ``}`,\n    ``\n  )\n}\n\nexport { GraphQLWebSocketClient } from './graphql-ws.js'\nexport { resolveRequestDocument } from './resolveRequestDocument.js'\nexport {\n  BatchRequestDocument,\n  batchRequests,\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  GraphQLClient,\n  rawRequest,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  request,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestMiddleware,\n  RequestOptions,\n  ResponseMiddleware,\n  Variables,\n}\nexport default request\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}